<?php
/**
 * @file
 * Query Arguments To URL tests.
 */

/**
 * Tests.
 */
class QueryParametersToURLTestCase extends DrupalWebTestCase {

  /**
   * Returns test info.
   */
  public static function getInfo() {
    return array(
      'name' => 'Query Parameters To URL tests',
      'description' => 'Test Query Parameters To URL functionality.',
      'group' => 'Query Parameters To URL',
    );
  }

  /**
   * Initial setup.
   */
  public function setUp() {
    parent::setUp(array('query_parameters_to_url'));

    // Enable rewriting on all paths.
    variable_set(QUERY_PARAMETERS_TO_URL_PATH_REG_EXP, '{.+}');

    // Create test node just for the sake of something being on the front page.
    $node = array(
      'type' => 'page',
      'title' => 'Test Page Node',
      'path' => array('alias' => 'test-node'),
      'language' => LANGUAGE_NONE,
      'promote' => 1,
    );

    // Save the node.
    $this->drupalCreateNode($node);
  }

  /**
   * Returns list of paths to test.
   */
  public function pathsToTest() {
    $paths = array();

    $paths[] = array(
      'path' => 'node',
      'options' => array(
        'query' => array(
          'a' => array(1, 2),
          'b' => array(
            'c' => 3,
          ),
        ),
      ),
      'expected_path' => 'node/p/a/0__1--1__2/b/c__3',
    );

    return $paths;
  }

  /**
   * Tests if a path with query parameters gets redirected to the clean path.
   */
  public function testRedirectWithQueryParameters() {
    $test_cases = $this->pathsToTest();
    foreach ($test_cases as $test_case) {
      list($path, $options, $expected_path) = $this->unpackTestCase($test_case);

      // Make sure they are absolute URLs.
      $path = $this->createRawUrl($path, $options);
      $expected_path = $this->createRawUrl($expected_path, array());

      // Make HEAD request and check the headers.
      $this->drupalHeadRawURL($path);
      $headers = $this->drupalGetHeaders(TRUE);

      $result = array(
        '!initial_path' => $path,
        '!expected_status' => '302',
        '!expected_path' => $expected_path,
        '!actual_path' => isset($headers[0]['location']) ? $headers[0]['location'] : 'N/A',
        '!actual_status' => $headers[0][':status'],
      );

      $this->assertStatusAndPath($result);
    }
  }

  /**
   * Tests if inbound/outbound hooks do their job.
   */
  public function testInboundOutboundURL() {
    $test_cases = $this->pathsToTest();
    foreach ($test_cases as $test_case) {
      list($path, $options, $expected_path) = $this->unpackTestCase($test_case);

      // Make sure they are absolute URLs.
      $expected_path = $this->createRawUrl($expected_path, array());

      // Make GET request and check the headers.
      $this->drupalGet($path, $options);
      $headers = $this->drupalGetHeaders(TRUE);

      $result = array(
        '!initial_path' => $path,
        '!expected_status' => '200',
        '!expected_path' => $expected_path,
        '!actual_path' => $this->getUrl(),
        '!actual_status' => $headers[0][':status'],
      );
      $this->assertStatusAndPath($result);
    }
  }

  /**
   * Creates full absolute URL without going through url function().
   */
  public function createRawUrl($path, $options) {
    global $base_url, $base_secure_url, $base_insecure_url;

    // The base_url might be rewritten from the language rewrite in domain mode.
    if (!isset($options['base_url'])) {
      if (isset($options['https']) && variable_get('https', FALSE)) {
        if ($options['https'] === TRUE) {
          $options['base_url'] = $base_secure_url;
          $options['absolute'] = TRUE;
        }
        elseif ($options['https'] === FALSE) {
          $options['base_url'] = $base_insecure_url;
          $options['absolute'] = TRUE;
        }
      }
      else {
        $options['base_url'] = $base_url;
      }
    }

    $base = $options['base_url'] . '/';

    if (isset($options['query']) && !empty($options['query'])) {
      return $base . $path . '?' . drupal_http_build_query($options['query']);
    }
    else {
      return $base . $path;
    }
  }

  /**
   * Unpacks test case.
   */
  public function unpackTestCase($test_case) {
    return array(
      $test_case['path'],
      $test_case['options'],
      $test_case['expected_path'],
    );
  }

  /**
   * Similar to drupalHead, but without piping to the url() function.
   */
  public function drupalHeadRawURL($path, array $headers = array()) {
    $out = $this->curlExec(array(CURLOPT_NOBODY => TRUE, CURLOPT_URL => $path, CURLOPT_HTTPHEADER => $headers));
    $this->refreshVariables(); // Ensure that any changes to variables in the other thread are picked up.
    return $out;
  }

  /**
   * Success message.
   */
  public function getSuccessMessage() {
    return 'SUCCESS<br />Initial Path: !initial_path<br />Expected Path: !expected_path<br />Expected Status Code: !expected_status<br />Actual path: !actual_path<br />Actual Status: !actual_status';
  }

  /**
   * Error message.
   */
  public function getErrorMessage() {
    return 'ERROR<br />Initial Path: !initial_path<br />Expected Path: !expected_path<br />Expected Status Code: !expected_status<br />Actual path: !actual_path<br />Actual Status: !actual_status';
  }

  /**
   * Checks if HTTP status code matches.
   */
  public function expectedStatus($status, $expected_status) {
    return strpos($status, (string)$expected_status) !== FALSE;
  }

  /**
   * Asserts that the status code and paths are equivalent.
   */
  public function assertStatusAndPath($result) {
    // Make sure status and paths actually match.
    if (
      $this->expectedStatus($result['!actual_status'], $result['!expected_status']) &&
      $result['!actual_path'] == $result['!expected_path']
    ) {
      $this->pass(format_string($this->getSuccessMessage(), $result));
    }
    else {
      $this->fail(format_string($this->getErrorMessage(), $result));
    }
  }
}