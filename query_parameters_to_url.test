<?php
/**
 * @file
 * Query Arguments To URL tests.
 */

/**
 * General test cases.
 */
class QueryParametersToURLTestCase extends DrupalWebTestCase {

  /**
   * Returns test info.
   */
  public static function getInfo() {
    return array(
      'name' => 'Query Parameters To URL Integration tests',
      'description' => 'Test Query Parameters To URL functionality.',
      'group' => 'Query Parameters To URL',
    );
  }

  /**
   * Initial setup.
   */
  public function setUp() {
    parent::setUp(array('query_parameters_to_url'));

    // Enable rewriting on all paths.
    variable_set(QUERY_PARAMETERS_TO_URL_PATH_REG_EXP, '{.+}');

    // Create test node just for the sake of something being on the front page.
    $node = array(
      'type' => 'page',
      'title' => 'Test Page Node',
      'path' => array('alias' => 'test-node'),
      'language' => LANGUAGE_NONE,
      'promote' => 1,
    );

    // Save the node.
    $this->drupalCreateNode($node);
  }

  /**
   * Returns list of paths to test.
   */
  public function pathsToTest() {
    $paths = array();

    $paths[] = array(
      'path' => 'node',
      'options' => array(
        'query' => array(
          'a' => array(1, 2),
          'b' => array(
            'c' => 3,
          ),
        ),
      ),
      'expected_path' => 'node/p/a/0__1--1__2/b/c__3',
    );

    return $paths;
  }

  /**
   * Tests if a path with query parameters gets redirected to the clean path.
   */
  public function testRedirectWithQueryParameters() {
    $test_cases = $this->pathsToTest();
    foreach ($test_cases as $test_case) {
      list($path, $options, $expected_path) = $this->unpackTestCase($test_case);

      // Make sure they are absolute URLs.
      $path = $this->createRawUrl($path, $options);
      $expected_path = $this->createRawUrl($expected_path, array());

      // Make HEAD request and check the headers.
      $this->drupalHeadRawURL($path);
      $headers = $this->drupalGetHeaders(TRUE);

      $result = array(
        '!initial_path' => $path,
        '!expected_status' => '302',
        '!expected_path' => $expected_path,
        '!actual_path' => isset($headers[0]['location']) ? $headers[0]['location'] : 'N/A',
        '!actual_status' => $headers[0][':status'],
      );

      $this->assertStatusAndPath($result);
    }
  }

  /**
   * Tests if inbound/outbound hooks do their job.
   */
  public function testInboundOutboundURL() {
    $test_cases = $this->pathsToTest();
    foreach ($test_cases as $test_case) {
      list($path, $options, $expected_path) = $this->unpackTestCase($test_case);

      // Make sure they are absolute URLs.
      $expected_path = $this->createRawUrl($expected_path, array());

      // Make GET request and check the headers.
      $this->drupalGet($path, $options);
      $headers = $this->drupalGetHeaders(TRUE);

      $result = array(
        '!initial_path' => $path,
        '!expected_status' => '200',
        '!expected_path' => $expected_path,
        '!actual_path' => $this->getUrl(),
        '!actual_status' => $headers[0][':status'],
      );
      $this->assertStatusAndPath($result);
    }
  }

  /**
   * Creates full absolute URL without going through url function().
   */
  public function createRawUrl($path, $options) {
    global $base_url, $base_secure_url, $base_insecure_url;

    // The base_url might be rewritten from the language rewrite in domain mode.
    if (!isset($options['base_url'])) {
      if (isset($options['https']) && variable_get('https', FALSE)) {
        if ($options['https'] === TRUE) {
          $options['base_url'] = $base_secure_url;
          $options['absolute'] = TRUE;
        }
        elseif ($options['https'] === FALSE) {
          $options['base_url'] = $base_insecure_url;
          $options['absolute'] = TRUE;
        }
      }
      else {
        $options['base_url'] = $base_url;
      }
    }

    $base = $options['base_url'] . '/';

    if (isset($options['query']) && !empty($options['query'])) {
      return $base . $path . '?' . drupal_http_build_query($options['query']);
    }
    else {
      return $base . $path;
    }
  }

  /**
   * Unpacks test case.
   */
  public function unpackTestCase($test_case) {
    return array(
      $test_case['path'],
      $test_case['options'],
      $test_case['expected_path'],
    );
  }

  /**
   * Similar to drupalHead, but without piping to the url() function.
   */
  public function drupalHeadRawURL($path, array $headers = array()) {
    $out = $this->curlExec(array(CURLOPT_NOBODY => TRUE, CURLOPT_URL => $path, CURLOPT_HTTPHEADER => $headers));
    $this->refreshVariables(); // Ensure that any changes to variables in the other thread are picked up.
    return $out;
  }

  /**
   * Success message.
   */
  public function getSuccessMessage() {
    return 'SUCCESS<br />Initial Path: !initial_path<br />Expected Path: !expected_path<br />Expected Status Code: !expected_status<br />Actual path: !actual_path<br />Actual Status: !actual_status';
  }

  /**
   * Error message.
   */
  public function getErrorMessage() {
    return 'ERROR<br />Initial Path: !initial_path<br />Expected Path: !expected_path<br />Expected Status Code: !expected_status<br />Actual path: !actual_path<br />Actual Status: !actual_status';
  }

  /**
   * Checks if HTTP status code matches.
   */
  public function expectedStatus($status, $expected_status) {
    return strpos($status, (string)$expected_status) !== FALSE;
  }

  /**
   * Asserts that the status code and paths are equivalent.
   */
  public function assertStatusAndPath($result) {
    // Make sure status and paths actually match.
    if (
      $this->expectedStatus($result['!actual_status'], $result['!expected_status']) &&
      $result['!actual_path'] == $result['!expected_path']
    ) {
      $this->pass(format_string($this->getSuccessMessage(), $result));
    }
    else {
      $this->fail(format_string($this->getErrorMessage(), $result));
    }
  }
}

/**
 * Class QueryParametersToURLUnitTestCase.
 */
class QueryParametersToURLUnitTestCase extends DrupalUnitTestCase {

  /**
   * Returns test info.
   */
  public static function getInfo() {
    return array(
      'name' => 'Query Parameters To URL Unit tests',
      'description' => 'Test query parameter values encoding / decoding.',
      'group' => 'Query Parameters To URL',
    );
  }

  /**
   * Returns a list of test cases.
   */
  public function getTestCases() {
    $test_cases = array();

    // ?value[a][1][2]=3&value[a][1][6]=7&value[b]=4&value[c]=5
    $test_cases[] = array(
      'parameter_value_array' => array(
        'a' => array(
          1 => array(
            2 => 3,
            6 => 7,
          ),
        ),
        'b' => 4,
        'c' => 5,
      ),
      'encoded_parameter_value_string' => 'a__1__2__3--a__1__6__7--b__4--c__5',
    );

    // ?f[0]=standard_page&f[1]=sm_og_group_ref:node:100
    $test_cases[] = array(
      'parameter_value_array' => array(
        0 => 'standard_page',
        1 => 'sm_og_group_ref:node:100',
      ),
      'encoded_parameter_value_string' => '0__standard_page--1__sm_og_group_ref:node:100',
    );

    return $test_cases;
  }

  /**
   * Unpacks a test case.
   */
  public function unpackTestCase($test_case) {
    return array(
      $test_case['parameter_value_array'],
      $test_case['encoded_parameter_value_string'],
    );
  }

  /**
   * Tests if a query parameter's values are properly encoded.
   */
  public function testQueryParameterValuesEncoding() {
    $test_cases = $this->getTestCases();
    foreach ($test_cases as $test_case) {
      list($parameter_values, $expected_query_parameter_string) = $this->unpackTestCase($test_case);

      $encoded_query_parameter = query_parameters_to_url_encode_query_parameter_values($parameter_values);

      $message = 'Query parameter values are encoded properly.<br/> Initial array:<br/>!initial<br/>Encoded to string:<br/>!string';
      $message = format_string($message, array(
        '!initial' => var_export($parameter_values, TRUE),
        '!string' => var_export($encoded_query_parameter, TRUE),
      ));
      $this->assertEqual($encoded_query_parameter, $expected_query_parameter_string, $message);
    }
  }

  /**
   * Tests if an encoded query parameter's values is properly decoded.
   */
  public function testQueryParameterValuesDecoding() {
    $test_cases = $this->getTestCases();
    foreach ($test_cases as $test_case) {
      list($expected_parameter_values, $encoded_parameter_string) = $this->unpackTestCase($test_case);

      $decoded_query_parameter_values = query_parameters_to_url_decode_query_parameter_values($encoded_parameter_string);

      $message = 'Query parameter values are decoded properly.<br/> Initial string:<br/>!initial<br/>Decoded to array:<br/>!array';
      $message = format_string($message, array(
        '!initial' => var_export($encoded_parameter_string, TRUE),
        '!array' => var_export($decoded_query_parameter_values, TRUE),
      ));
      $this->assertEqual($decoded_query_parameter_values, $expected_parameter_values, $message);
    }
  }
}
